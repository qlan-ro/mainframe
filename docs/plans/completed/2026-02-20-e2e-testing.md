# E2E Testing Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add two layers of automated testing — Vitest daemon API tests (runs in CI) and Playwright Electron UI tests (runs locally).

**Architecture:** Layer 1 tests spawn a real daemon with a random free port and temp SQLite DB, then hit its HTTP API with `fetch`. Layer 2 tests build the Electron app, start a test daemon, and launch Electron with `NODE_ENV=development` (which already skips daemon spawning) plus `MF_DAEMON_PORT` to redirect the renderer to the test daemon.

**Tech Stack:** Vitest (already installed in workspace), tsx (already in `@mainframe/core` devDeps), `@playwright/test`, Node.js `net` module for port allocation.

---

## Background: What Exists

- `packages/core/src/config.ts` — `getConfig()` reads `~/.mainframe/config.json`, defaults port to 31415. **No env var support yet.**
- `packages/desktop/src/renderer/lib/api/http.ts` — `API_BASE` hardcoded to `'http://127.0.0.1:31415'`.
- `packages/desktop/src/renderer/lib/client.ts` — `WS_URL` hardcoded to `'ws://127.0.0.1:31415'`.
- `packages/desktop/src/preload/index.ts` — exposes `window.mainframe` via `contextBridge`. Preload runs in main-process context so it has access to `process.env`.
- `packages/desktop/src/main/index.ts` — when `NODE_ENV === 'development'`, skips daemon spawn and (if `ELECTRON_RENDERER_URL` is not set) loads the built renderer from `out/renderer/index.html`.

---

## Task 1: Add env var overrides to `getConfig()` and `getDataDir()`

**Why first:** Every other task depends on the daemon accepting a custom port and data directory via env vars. This is the only production-code change needed for Layer 1.

**Files:**
- Modify: `packages/core/src/config.ts`
- Modify: `packages/core/src/__tests__/config.test.ts` (create new)

### Step 1: Write the failing test

Create `packages/core/src/__tests__/config.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';

describe('getConfig env var overrides', () => {
  const originalEnv = process.env;

  beforeEach(() => {
    process.env = { ...originalEnv };
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  it('uses default port when MAINFRAME_PORT is not set', async () => {
    delete process.env.MAINFRAME_PORT;
    const { getConfig } = await import('../config.js');
    const config = getConfig();
    expect(config.port).toBe(31415);
  });

  it('overrides port from MAINFRAME_PORT env var', async () => {
    process.env.MAINFRAME_PORT = '12345';
    // Clear module cache so env var is re-read
    const { getConfig } = await import('../config.js?v=port');
    const config = getConfig();
    expect(config.port).toBe(12345);
  });

  it('overrides dataDir from MAINFRAME_DATA_DIR env var', async () => {
    process.env.MAINFRAME_DATA_DIR = '/tmp/test-mainframe-data';
    const { getDataDir } = await import('../config.js?v=datadir');
    const dir = getDataDir();
    expect(dir).toBe('/tmp/test-mainframe-data');
  });
});
```

> **Note:** Vitest re-imports modules with a cache-busting query string to work around ESM caching. This is a known workaround for testing module-level side effects. If this doesn't work cleanly (ESM caching is tricky), just write integration-level tests via the daemon helper in Task 3 and skip these unit tests.

### Step 2: Run test to verify it fails

```bash
pnpm --filter @mainframe/core test -- --run src/__tests__/config.test.ts
```

Expected: FAIL — `getConfig()` ignores env vars.

### Step 3: Implement env var support

Edit `packages/core/src/config.ts`:

```typescript
import { homedir } from 'node:os';
import { join } from 'node:path';
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';

export interface MainframeConfig {
  port: number;
  dataDir: string;
}

const DEFAULT_CONFIG: MainframeConfig = {
  port: 31415,
  dataDir: join(homedir(), '.mainframe'),
};

export function getDataDir(): string {
  const dir = process.env.MAINFRAME_DATA_DIR ?? DEFAULT_CONFIG.dataDir;
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
  return dir;
}

export function getConfig(): MainframeConfig {
  const configPath = join(getDataDir(), 'config.json');
  let fromFile: Partial<MainframeConfig> = {};
  if (existsSync(configPath)) {
    try {
      fromFile = JSON.parse(readFileSync(configPath, 'utf-8')) as Partial<MainframeConfig>;
    } catch { /* ignore corrupt config */ }
  }

  const merged = { ...DEFAULT_CONFIG, ...fromFile };
  if (process.env.MAINFRAME_PORT) merged.port = parseInt(process.env.MAINFRAME_PORT, 10);
  if (process.env.MAINFRAME_DATA_DIR) merged.dataDir = process.env.MAINFRAME_DATA_DIR;
  return merged;
}

export function saveConfig(config: Partial<MainframeConfig>): void {
  const configPath = join(getDataDir(), 'config.json');
  const current = getConfig();
  const merged = { ...current, ...config };
  writeFileSync(configPath, JSON.stringify(merged, null, 2));
}
```

### Step 4: Run test to verify it passes

```bash
pnpm --filter @mainframe/core test -- --run src/__tests__/config.test.ts
```

> If module caching prevents the unit tests from passing, delete the unit tests and verify env var behavior is covered by the integration tests in Task 4 (the daemon fixture exercises this end-to-end). Don't fight ESM cache — move on.

### Step 5: Typecheck

```bash
pnpm --filter @mainframe/core build
```

Expected: no errors.

### Step 6: Commit

```bash
git add packages/core/src/config.ts packages/core/src/__tests__/config.test.ts
git commit -m "feat: add MAINFRAME_PORT and MAINFRAME_DATA_DIR env var overrides to getConfig"
```

---

## Task 2: Scaffold `tests/` directory and add root devDependencies

**Files:**
- Create: `tests/vitest.config.ts`
- Create: `tests/api/helpers/.gitkeep` (just to create the directory)
- Modify: root `package.json` (add `test:api` script)

### Step 1: Install vitest and tsx at workspace root

```bash
pnpm add -D -w vitest tsx
```

(`-w` targets the workspace root)

### Step 2: Create `tests/vitest.config.ts`

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    include: ['tests/api/**/*.test.ts'],
    testTimeout: 30_000,
    hookTimeout: 60_000,
  },
});
```

- `testTimeout: 30_000` — each test gets 30s (HTTP calls to a subprocess).
- `hookTimeout: 60_000` — `beforeAll` gets 60s to spawn and wait for the daemon.

### Step 3: Add `test:api` script to root `package.json`

Edit the `"scripts"` block in `package.json`:

```json
"test:api": "vitest run --config tests/vitest.config.ts"
```

### Step 4: Verify the config is valid

```bash
pnpm test:api
```

Expected: "No test files found" — that's fine, no tests exist yet.

### Step 5: Commit

```bash
git add tests/vitest.config.ts package.json pnpm-lock.yaml
git commit -m "feat: scaffold tests/ directory with vitest config and test:api script"
```

---

## Task 3: Create daemon test helper

**Files:**
- Create: `tests/api/helpers/daemon.ts`

This module provides `startTestDaemon()`, which:
1. Finds a free port (OS allocates one via `net.createServer().listen(0)`)
2. Creates a temp directory
3. Spawns `tsx packages/core/src/index.ts` with `MAINFRAME_PORT` and `MAINFRAME_DATA_DIR` env vars
4. Polls `GET /api/projects` until it returns 200 (up to 15s)
5. Returns `{ baseUrl, cleanup }`

### Step 1: Create `tests/api/helpers/daemon.ts`

```typescript
import { createServer } from 'node:net';
import { mkdtempSync } from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { spawn, type ChildProcess } from 'node:child_process';
import { fileURLToPath } from 'node:url';

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const REPO_ROOT = join(__dirname, '../../..');
const DAEMON_ENTRY = join(REPO_ROOT, 'packages/core/src/index.ts');

export interface DaemonFixture {
  baseUrl: string;
  port: number;
  cleanup: () => Promise<void>;
}

function findFreePort(): Promise<number> {
  return new Promise((resolve, reject) => {
    const server = createServer();
    server.listen(0, '127.0.0.1', () => {
      const addr = server.address() as { port: number };
      server.close((err) => (err ? reject(err) : resolve(addr.port)));
    });
    server.on('error', reject);
  });
}

async function waitForDaemon(baseUrl: string, maxWaitMs = 15_000): Promise<void> {
  const start = Date.now();
  while (Date.now() - start < maxWaitMs) {
    try {
      const res = await fetch(`${baseUrl}/api/projects`);
      if (res.ok) return;
    } catch {
      // not ready yet
    }
    await new Promise((r) => setTimeout(r, 150));
  }
  throw new Error(`Daemon at ${baseUrl} did not become ready within ${maxWaitMs}ms`);
}

export async function startTestDaemon(): Promise<DaemonFixture> {
  const port = await findFreePort();
  const dataDir = mkdtempSync(join(tmpdir(), 'mf-test-'));

  const proc: ChildProcess = spawn('tsx', [DAEMON_ENTRY], {
    env: {
      ...process.env,
      MAINFRAME_PORT: String(port),
      MAINFRAME_DATA_DIR: dataDir,
      LOG_LEVEL: 'silent',
    },
    stdio: 'pipe',
  });

  // surface fatal startup errors
  proc.stderr?.on('data', (chunk: Buffer) => {
    const line = chunk.toString();
    if (line.includes('Error') || line.includes('error')) {
      process.stderr.write(`[test-daemon:${port}] ${line}`);
    }
  });

  const baseUrl = `http://127.0.0.1:${port}`;
  await waitForDaemon(baseUrl);

  const cleanup = (): Promise<void> =>
    new Promise((resolve) => {
      proc.on('exit', () => resolve());
      proc.kill('SIGTERM');
    });

  return { baseUrl, port, cleanup };
}
```

### Step 2: Smoke-test the helper by writing a minimal test

Create `tests/api/smoke.test.ts` (temporary, will be deleted after):

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { startTestDaemon, type DaemonFixture } from './helpers/daemon.js';

describe('daemon smoke test', () => {
  let daemon: DaemonFixture;

  beforeAll(async () => {
    daemon = await startTestDaemon();
  }, 60_000);

  afterAll(async () => {
    await daemon.cleanup();
  });

  it('responds to GET /api/projects', async () => {
    const res = await fetch(`${daemon.baseUrl}/api/projects`);
    expect(res.status).toBe(200);
    const body = await res.json();
    expect(body).toEqual({ success: true, data: [] });
  });
});
```

### Step 3: Run the smoke test

```bash
pnpm test:api
```

Expected: PASS. If you see "tsx not found", run `pnpm add -D -w tsx` and retry.

### Step 4: Delete the smoke test

```bash
rm tests/api/smoke.test.ts
```

### Step 5: Commit

```bash
git add tests/api/helpers/daemon.ts
git commit -m "feat: add daemon test helper for Layer 1 API tests"
```

---

## Task 4: Write `tests/api/projects.test.ts`

**Files:**
- Create: `tests/api/projects.test.ts`

### Step 1: Write the test file

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { startTestDaemon, type DaemonFixture } from './helpers/daemon.js';

describe('projects API', () => {
  let daemon: DaemonFixture;

  beforeAll(async () => {
    daemon = await startTestDaemon();
  }, 60_000);

  afterAll(async () => {
    await daemon.cleanup();
  });

  describe('GET /api/projects', () => {
    it('returns empty list initially', async () => {
      const res = await fetch(`${daemon.baseUrl}/api/projects`);
      expect(res.status).toBe(200);
      const body = await res.json();
      expect(body).toEqual({ success: true, data: [] });
    });
  });

  describe('POST /api/projects', () => {
    it('creates a new project', async () => {
      const res = await fetch(`${daemon.baseUrl}/api/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: '/tmp/proj-a', name: 'Project A' }),
      });
      expect(res.status).toBe(200);
      const body = await res.json();
      expect(body.success).toBe(true);
      expect(body.data.path).toBe('/tmp/proj-a');
      expect(body.data.name).toBe('Project A');
      expect(typeof body.data.id).toBe('string');
    });

    it('returns existing project when path is already registered', async () => {
      // Create once
      const first = await fetch(`${daemon.baseUrl}/api/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: '/tmp/proj-dupe', name: 'Dupe' }),
      });
      const { data: created } = await first.json();

      // Create again with same path
      const second = await fetch(`${daemon.baseUrl}/api/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: '/tmp/proj-dupe', name: 'Dupe Again' }),
      });
      expect(second.status).toBe(200);
      const { data: returned } = await second.json();
      expect(returned.id).toBe(created.id); // same record
    });

    it('rejects a request with no path', async () => {
      const res = await fetch(`${daemon.baseUrl}/api/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: 'No Path' }),
      });
      expect(res.status).toBe(400);
      const body = await res.json();
      expect(body.success).toBe(false);
    });
  });

  describe('GET /api/projects after creating', () => {
    it('lists all created projects', async () => {
      // Create two projects unique to this test
      for (const path of ['/tmp/list-a', '/tmp/list-b']) {
        await fetch(`${daemon.baseUrl}/api/projects`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path }),
        });
      }
      const res = await fetch(`${daemon.baseUrl}/api/projects`);
      const { data } = await res.json();
      const paths = data.map((p: { path: string }) => p.path);
      expect(paths).toContain('/tmp/list-a');
      expect(paths).toContain('/tmp/list-b');
    });
  });

  describe('DELETE /api/projects/:id', () => {
    it('removes a project', async () => {
      const created = await (
        await fetch(`${daemon.baseUrl}/api/projects`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: '/tmp/to-delete' }),
        })
      ).json();

      const del = await fetch(`${daemon.baseUrl}/api/projects/${created.data.id}`, {
        method: 'DELETE',
      });
      expect(del.status).toBe(200);
      const body = await del.json();
      expect(body.success).toBe(true);

      // Verify gone
      const list = await (await fetch(`${daemon.baseUrl}/api/projects`)).json();
      const ids = list.data.map((p: { id: string }) => p.id);
      expect(ids).not.toContain(created.data.id);
    });

    it('handles unknown project id gracefully (no 500)', async () => {
      const res = await fetch(`${daemon.baseUrl}/api/projects/does-not-exist`, {
        method: 'DELETE',
      });
      // Route calls removeWithChats which silently does nothing for unknown IDs
      // Acceptable: either 200 (idempotent) or 404 — just not 500
      expect(res.status).not.toBe(500);
    });
  });
});
```

### Step 2: Run tests

```bash
pnpm test:api
```

Expected: all pass.

### Step 3: Commit

```bash
git add tests/api/projects.test.ts
git commit -m "test: add Layer 1 projects API integration tests"
```

---

## Task 5: Write `tests/api/chats.test.ts`

**Files:**
- Create: `tests/api/chats.test.ts`

> **Context:** Chat creation is done via WebSocket (`chat.create` event), which also tries to spawn the Claude CLI. To avoid spawning real CLI processes, these tests only cover HTTP routes that don't require a live chat session: listing chats (empty list) and 404 behavior.

### Step 1: Write the test file

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { startTestDaemon, type DaemonFixture } from './helpers/daemon.js';

describe('chats API', () => {
  let daemon: DaemonFixture;
  let projectId: string;

  beforeAll(async () => {
    daemon = await startTestDaemon();

    // Create a project to hang chats off
    const res = await fetch(`${daemon.baseUrl}/api/projects`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: '/tmp/chats-test-project' }),
    });
    const body = await res.json();
    projectId = body.data.id;
  }, 60_000);

  afterAll(async () => {
    await daemon.cleanup();
  });

  describe('GET /api/projects/:id/chats', () => {
    it('returns empty list for a new project', async () => {
      const res = await fetch(`${daemon.baseUrl}/api/projects/${projectId}/chats`);
      expect(res.status).toBe(200);
      const body = await res.json();
      expect(body).toEqual({ success: true, data: [] });
    });
  });

  describe('GET /api/chats/:id', () => {
    it('returns 404 for unknown chat id', async () => {
      const res = await fetch(`${daemon.baseUrl}/api/chats/nonexistent-chat-id`);
      expect(res.status).toBe(404);
      const body = await res.json();
      expect(body.success).toBe(false);
    });
  });

  describe('POST /api/chats/:id/archive', () => {
    it('returns non-500 for unknown chat id', async () => {
      const res = await fetch(`${daemon.baseUrl}/api/chats/nonexistent/archive`, {
        method: 'POST',
      });
      // Route catches the error and returns 404, not 500
      expect(res.status).not.toBe(500);
    });
  });
});
```

### Step 2: Run tests

```bash
pnpm test:api
```

Expected: all pass.

### Step 3: Commit

```bash
git add tests/api/chats.test.ts
git commit -m "test: add Layer 1 chats API integration tests"
```

---

## Task 6: Write `tests/api/delete-cascade.test.ts`

**Files:**
- Create: `tests/api/delete-cascade.test.ts`

### Step 1: Write the test file

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { startTestDaemon, type DaemonFixture } from './helpers/daemon.js';

describe('delete cascade', () => {
  let daemon: DaemonFixture;

  beforeAll(async () => {
    daemon = await startTestDaemon();
  }, 60_000);

  afterAll(async () => {
    await daemon.cleanup();
  });

  it('deleting a project removes it from the projects list', async () => {
    const created = await (
      await fetch(`${daemon.baseUrl}/api/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: '/tmp/cascade-test' }),
      })
    ).json();
    const id = created.data.id;

    await fetch(`${daemon.baseUrl}/api/projects/${id}`, { method: 'DELETE' });

    const list = await (await fetch(`${daemon.baseUrl}/api/projects`)).json();
    const ids = list.data.map((p: { id: string }) => p.id);
    expect(ids).not.toContain(id);
  });

  it('deleting a project with no chats succeeds', async () => {
    const created = await (
      await fetch(`${daemon.baseUrl}/api/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: '/tmp/cascade-empty' }),
      })
    ).json();

    const res = await fetch(`${daemon.baseUrl}/api/projects/${created.data.id}`, {
      method: 'DELETE',
    });
    expect(res.status).toBe(200);
    expect((await res.json()).success).toBe(true);
  });

  it('chat list returns empty after project deletion', async () => {
    const created = await (
      await fetch(`${daemon.baseUrl}/api/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: '/tmp/cascade-chats' }),
      })
    ).json();
    const id = created.data.id;

    await fetch(`${daemon.baseUrl}/api/projects/${id}`, { method: 'DELETE' });

    // After deletion the project is gone — its chats endpoint should 404 or return empty
    const chatsRes = await fetch(`${daemon.baseUrl}/api/projects/${id}/chats`);
    // Either 200 with empty data or 404 — both are acceptable outcomes
    if (chatsRes.status === 200) {
      const body = await chatsRes.json();
      expect(body.data).toEqual([]);
    } else {
      expect(chatsRes.status).toBe(404);
    }
  });
});
```

### Step 2: Run all API tests

```bash
pnpm test:api
```

Expected: all pass.

### Step 3: Commit

```bash
git add tests/api/delete-cascade.test.ts
git commit -m "test: add Layer 1 delete-cascade integration tests"
```

---

## Task 7: Add `test:api` to CI

**Files:**
- Modify: `.github/workflows/ci.yml`

### Step 1: Add the test step to `ci.yml`

Add a new step after the existing `Test` step:

```yaml
      - name: API integration tests
        run: pnpm test:api
```

The full `jobs.build-and-test.steps` block should look like:

```yaml
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: 9

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - run: pnpm install --frozen-lockfile

      - name: Type check
        run: pnpm build
        env:
          NODE_OPTIONS: '--max-old-space-size=4096'

      - name: Test
        run: pnpm test

      - name: API integration tests
        run: pnpm test:api

      - name: Security audit
        run: pnpm audit --audit-level=high
        continue-on-error: true
```

### Step 2: Verify CI file is valid YAML

```bash
node -e "const yaml = require('js-yaml'); yaml.load(require('fs').readFileSync('.github/workflows/ci.yml', 'utf8')); console.log('valid')" 2>/dev/null || python3 -c "import yaml,sys; yaml.safe_load(open('.github/workflows/ci.yml')); print('valid')"
```

Expected: `valid`

### Step 3: Commit

```bash
git add .github/workflows/ci.yml
git commit -m "ci: run Layer 1 API integration tests in CI"
```

---

## Task 8: Install Playwright and create `playwright.config.ts`

> **Note:** Layer 2 tests require a macOS/Linux display. Not run in CI.

**Files:**
- Modify: root `package.json` (add `test:e2e` script)
- Create: `tests/playwright.config.ts`

### Step 1: Install Playwright at workspace root

```bash
pnpm add -D -w @playwright/test playwright
```

### Step 2: Install Playwright browser binaries

```bash
pnpm exec playwright install
```

(We need Chromium for Electron's DevTools Protocol; Electron bundles its own Chromium, but Playwright still needs the CDP client.)

### Step 3: Create `tests/playwright.config.ts`

```typescript
import { defineConfig } from '@playwright/test';

export default defineConfig({
  testDir: 'tests/e2e',
  timeout: 60_000,
  retries: 0,
  workers: 1, // Electron tests must run serially — one app instance at a time
  reporter: [['list']],
  use: {
    // Electron doesn't support headless mode — window is always shown
    headless: false,
  },
});
```

### Step 4: Add `test:e2e` to root `package.json`

In `scripts`:

```json
"test:e2e": "playwright test --config tests/playwright.config.ts"
```

### Step 5: Verify config is valid

```bash
pnpm exec playwright test --config tests/playwright.config.ts --list 2>&1 | head -5
```

Expected: "No tests found" or similar — fine, no tests exist yet.

### Step 6: Commit

```bash
git add tests/playwright.config.ts package.json pnpm-lock.yaml
git commit -m "feat: install Playwright and add test:e2e script for Layer 2 tests"
```

---

## Task 9: Update preload and renderer to support `MF_DAEMON_PORT`

**Why:** Playwright tests start a test daemon on a non-31415 port. The renderer (which runs in a browser context inside Electron) needs to know this port. The preload script (which runs in the main-process context) can read `process.env` and bridge the value to the renderer via `contextBridge`.

**Files:**
- Modify: `packages/desktop/src/preload/index.ts`
- Modify: `packages/desktop/src/renderer/lib/api/http.ts`
- Modify: `packages/desktop/src/renderer/lib/client.ts`

### Step 1: Update the preload

Edit `packages/desktop/src/preload/index.ts`:

```typescript
import { contextBridge, ipcRenderer } from 'electron';

export interface MainframeAPI {
  platform: NodeJS.Platform;
  versions: {
    node: string;
    chrome: string;
    electron: string;
  };
  daemonPort: number;
  getAppInfo: () => Promise<{ version: string; author: string }>;
  openDirectoryDialog: () => Promise<string | null>;
  readFile: (filePath: string) => Promise<string | null>;
}

const api: MainframeAPI = {
  platform: process.platform,
  versions: {
    node: process.versions.node,
    chrome: process.versions.chrome,
    electron: process.versions.electron,
  },
  daemonPort: process.env.MF_DAEMON_PORT ? parseInt(process.env.MF_DAEMON_PORT, 10) : 31415,
  getAppInfo: () => ipcRenderer.invoke('app:getInfo'),
  openDirectoryDialog: () => ipcRenderer.invoke('dialog:openDirectory'),
  readFile: (filePath: string) => ipcRenderer.invoke('fs:readFile', filePath),
};

contextBridge.exposeInMainWorld('mainframe', api);
```

### Step 2: Update `http.ts` to read port dynamically

Edit `packages/desktop/src/renderer/lib/api/http.ts`:

```typescript
// The daemon port is injected by the preload at startup time.
// Falls back to 31415 in any non-Electron environment (e.g. unit tests).
function daemonPort(): number {
  return (window as unknown as { mainframe?: { daemonPort?: number } }).mainframe?.daemonPort ?? 31415;
}

const API_BASE = `http://127.0.0.1:${daemonPort()}`;

async function fetchJson<T>(url: string): Promise<T> {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}

async function postJson<T>(url: string, body?: unknown): Promise<T> {
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    ...(body !== undefined ? { body: JSON.stringify(body) } : {}),
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}

async function putJson<T>(url: string, body: unknown): Promise<T> {
  const res = await fetch(url, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}

async function deleteRequest(url: string): Promise<void> {
  const res = await fetch(url, { method: 'DELETE' });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
}

export { API_BASE, fetchJson, postJson, putJson, deleteRequest };
```

### Step 3: Update `client.ts` to read port dynamically

Edit `packages/desktop/src/renderer/lib/client.ts` — change the top constant:

```typescript
// The daemon port is injected by the preload at startup time.
const WS_URL = `ws://127.0.0.1:${(window as unknown as { mainframe?: { daemonPort?: number } }).mainframe?.daemonPort ?? 31415}`;
```

(Replace just the `const WS_URL = 'ws://127.0.0.1:31415';` line — rest of the file is unchanged.)

### Step 4: Typecheck

```bash
pnpm --filter @mainframe/desktop build
```

Expected: no errors.

### Step 5: Run desktop tests

```bash
pnpm --filter @mainframe/desktop test
```

Expected: all pass (this change is backward-compatible — if `window.mainframe` is absent, defaults to 31415).

### Step 6: Commit

```bash
git add packages/desktop/src/preload/index.ts packages/desktop/src/renderer/lib/api/http.ts packages/desktop/src/renderer/lib/client.ts
git commit -m "feat: read daemon port from MF_DAEMON_PORT env via preload for Playwright test isolation"
```

---

## Task 10: Create Electron test fixture

**Files:**
- Create: `tests/e2e/fixtures.ts`

**Prerequisites:** The Electron app must be built before running E2E tests. Run `pnpm build:desktop` once before the first test run.

**Strategy:**
- Start a test daemon on port 31999 (fixed, easy to debug)
- Launch Electron with `NODE_ENV=development` (skips daemon spawn) and `MF_DAEMON_PORT=31999`
- Electron loads the built renderer from `out/renderer/index.html`
- Yield `page` (first Electron window) to each test

### Step 1: Create `tests/e2e/fixtures.ts`

```typescript
import { test as base, _electron as electron } from '@playwright/test';
import type { ElectronApplication, Page } from '@playwright/test';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { startTestDaemon, type DaemonFixture } from '../api/helpers/daemon.js';

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const REPO_ROOT = join(__dirname, '../..');
const ELECTRON_MAIN = join(REPO_ROOT, 'packages/desktop/out/main/index.js');
const TEST_DAEMON_PORT = 31999;

export const test = base.extend<{
  daemon: DaemonFixture;
  electronApp: ElectronApplication;
  page: Page;
}>({
  daemon: async ({}, use) => {
    const daemon = await startTestDaemon();
    // Override port to the fixed test port so it's predictable
    // (startTestDaemon uses a random port internally, so we use a fixed one here instead)
    await use(daemon);
    await daemon.cleanup();
  },

  electronApp: async ({}, use) => {
    // Start the test daemon on a fixed port for easier debugging
    const daemon = await startTestDaemon();

    const app = await electron.launch({
      args: [ELECTRON_MAIN],
      env: {
        ...process.env,
        NODE_ENV: 'development',
        MF_DAEMON_PORT: String(daemon.port),
        // Do NOT set ELECTRON_RENDERER_URL — we want the built renderer
      },
    });

    await use(app);

    await app.close();
    await daemon.cleanup();
  },

  page: async ({ electronApp }, use) => {
    const page = await electronApp.firstWindow();
    // Wait for the app's main content to load
    await page.waitForLoadState('domcontentloaded');
    await use(page);
  },
});

export { expect } from '@playwright/test';
```

> **Note:** The `daemon` fixture above is unused in the composed fixture because `electronApp` manages its own daemon. The separate `daemon` fixture exists in case you need direct HTTP access alongside the UI test (see `projects.spec.ts`). For simplicity, `electronApp` creates its own daemon internally.

**Revised, simpler `fixtures.ts`** (replace the above with this):

```typescript
import { test as base, _electron as electron } from '@playwright/test';
import type { ElectronApplication, Page } from '@playwright/test';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { startTestDaemon, type DaemonFixture } from '../api/helpers/daemon.js';

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const REPO_ROOT = join(__dirname, '../..');
const ELECTRON_MAIN = join(REPO_ROOT, 'packages/desktop/out/main/index.js');

interface ElectronFixtures {
  electronApp: ElectronApplication;
  daemon: DaemonFixture;
  page: Page;
}

export const test = base.extend<ElectronFixtures>({
  daemon: [
    async ({}, use) => {
      const d = await startTestDaemon();
      await use(d);
      await d.cleanup();
    },
    { scope: 'test' },
  ],

  electronApp: [
    async ({ daemon }, use) => {
      const app = await electron.launch({
        args: [ELECTRON_MAIN],
        env: {
          ...process.env,
          NODE_ENV: 'development',
          MF_DAEMON_PORT: String(daemon.port),
        },
      });
      await use(app);
      await app.close();
    },
    { scope: 'test' },
  ],

  page: [
    async ({ electronApp }, use) => {
      const p = await electronApp.firstWindow();
      await p.waitForLoadState('domcontentloaded');
      await use(p);
    },
    { scope: 'test' },
  ],
});

export { expect } from '@playwright/test';
```

### Step 2: Commit

```bash
git add tests/e2e/fixtures.ts
git commit -m "feat: add Playwright Electron test fixture with test daemon injection"
```

---

## Task 11: Write `tests/e2e/projects.spec.ts`

**Prerequisite:** `pnpm build:desktop` must have been run at least once.

**Files:**
- Create: `tests/e2e/projects.spec.ts`

These tests exercise the ProjectRail UI: adding a project via directory dialog and removing it via the hover-confirm flow.

The `openDirectoryDialog` IPC handler uses `dialog.showOpenDialog`. We mock it via `electronApp.evaluate()` before each test so no real file dialog appears.

### Step 1: Create `tests/e2e/projects.spec.ts`

```typescript
import { test, expect } from './fixtures.js';

test.describe('ProjectRail', () => {
  test.beforeEach(async ({ electronApp }) => {
    // Mock the directory dialog to return a fixed path without showing UI
    await electronApp.evaluate(({ ipcMain }) => {
      ipcMain.removeHandler('dialog:openDirectory');
      ipcMain.handle('dialog:openDirectory', () => '/tmp/e2e-test-project');
    });
  });

  test('adds a project via directory dialog and shows it in the rail', async ({ page }) => {
    // Click the "Add Project" button (Plus icon)
    await page.click('[aria-label="Add project"]');

    // The project should now appear in the rail as a button with initials
    // The project name is derived from the path: 'e2e-test-project' → first char 'e' or 'E'
    await expect(page.locator('[title="e2e-test-project"]')).toBeVisible({ timeout: 5_000 });
  });

  test('hover on project button reveals remove badge', async ({ page }) => {
    // First add a project
    await page.click('[aria-label="Add project"]');
    const projectBtn = page.locator('[title="e2e-test-project"]');
    await expect(projectBtn).toBeVisible({ timeout: 5_000 });

    // Hover over it
    await projectBtn.hover();

    // The ✕ remove button should appear (aria-label="Remove project")
    await expect(page.locator('[aria-label="Remove project"]')).toBeVisible({ timeout: 2_000 });
  });

  test('clicking ✕ shows inline confirm/cancel', async ({ page }) => {
    await page.click('[aria-label="Add project"]');
    const projectBtn = page.locator('[title="e2e-test-project"]');
    await expect(projectBtn).toBeVisible({ timeout: 5_000 });

    await projectBtn.hover();
    await page.click('[aria-label="Remove project"]');

    // Confirm (✓) and cancel (✕) buttons should appear
    await expect(page.locator('[aria-label="Confirm remove project"]')).toBeVisible({ timeout: 2_000 });
    await expect(page.locator('[aria-label="Cancel remove project"]')).toBeVisible({ timeout: 2_000 });
  });

  test('mouse leave cancels the confirm state', async ({ page }) => {
    await page.click('[aria-label="Add project"]');
    const projectBtn = page.locator('[title="e2e-test-project"]');
    await expect(projectBtn).toBeVisible({ timeout: 5_000 });

    await projectBtn.hover();
    await page.click('[aria-label="Remove project"]');
    await expect(page.locator('[aria-label="Confirm remove project"]')).toBeVisible({ timeout: 2_000 });

    // Move mouse away from the project area
    await page.mouse.move(0, 0);

    // Confirm button should disappear
    await expect(page.locator('[aria-label="Confirm remove project"]')).not.toBeVisible({ timeout: 2_000 });
  });

  test('confirming removal removes project from the rail', async ({ page }) => {
    await page.click('[aria-label="Add project"]');
    const projectBtn = page.locator('[title="e2e-test-project"]');
    await expect(projectBtn).toBeVisible({ timeout: 5_000 });

    await projectBtn.hover();
    await page.click('[aria-label="Remove project"]');
    await page.click('[aria-label="Confirm remove project"]');

    // Project should be gone from the rail
    await expect(page.locator('[title="e2e-test-project"]')).not.toBeVisible({ timeout: 5_000 });
  });
});
```

> **Important:** These tests rely on `aria-label` attributes on the ProjectRail buttons. Before running, verify the `ProjectRail.tsx` component has:
> - The Plus button: `aria-label="Add project"` ✓ (already exists)
> - The ✕ hover button: `aria-label="Remove project"` — **must be added in the JSX**
> - The ✓ confirm button: `aria-label="Confirm remove project"` — **must be added**
> - The cancel button: `aria-label="Cancel remove project"` — **must be added**
>
> Read `packages/desktop/src/renderer/components/ProjectRail.tsx` and add the missing `aria-label` props to the remove/confirm/cancel buttons before running these tests.

### Step 2: Add missing `aria-label` props to `ProjectRail.tsx`

Open `packages/desktop/src/renderer/components/ProjectRail.tsx`. Find the remove (✕), confirm (✓), and cancel buttons added in the previous feature work. Add:
- Remove trigger: `aria-label="Remove project"`
- Confirm: `aria-label="Confirm remove project"`
- Cancel: `aria-label="Cancel remove project"`

### Step 3: Build and run the E2E tests

```bash
pnpm build:desktop
pnpm test:e2e
```

Expected: all 5 tests pass. The Electron window will briefly appear and close for each test.

If tests fail because project name doesn't match, check what `project.name` is set to when the path is `/tmp/e2e-test-project`. Adjust the `[title="..."]` selector to match the actual name.

### Step 4: Commit

```bash
git add tests/e2e/projects.spec.ts
git commit -m "test: add Layer 2 Playwright E2E tests for ProjectRail add/remove flow"
```

---

## Task 12: Write `tests/e2e/chats.spec.ts`

**Files:**
- Create: `tests/e2e/chats.spec.ts`

These tests verify that selecting a project shows a chat list and that switching projects shows different lists.

> **Note:** Since no Claude CLI is involved, creating chats requires sending a WebSocket message via the app. However, these tests focus on navigation behavior, so we test with empty chat lists (zero chats in the new project). Extend later when you have a way to seed test chats.

### Step 1: Create `tests/e2e/chats.spec.ts`

```typescript
import { test, expect } from './fixtures.js';

test.describe('Chat list', () => {
  test.beforeEach(async ({ electronApp }) => {
    await electronApp.evaluate(({ ipcMain }) => {
      ipcMain.removeHandler('dialog:openDirectory');
      ipcMain.handle('dialog:openDirectory', () => '/tmp/e2e-chats-project');
    });
  });

  test('selecting a project shows the chat panel', async ({ page }) => {
    // Add a project
    await page.click('[aria-label="Add project"]');
    await expect(page.locator('[title="e2e-chats-project"]')).toBeVisible({ timeout: 5_000 });

    // Click the project button to select it
    await page.click('[title="e2e-chats-project"]');

    // The chat list area should be visible (empty state or chat items)
    // The exact selector depends on the ChatList component — adjust as needed
    await expect(page.locator('[data-testid="chat-list"]').or(page.locator('text=No chats'))).toBeVisible({
      timeout: 5_000,
    });
  });

  test('switching projects shows different chat contexts', async ({ page, electronApp }) => {
    // Add first project
    await page.click('[aria-label="Add project"]');
    await expect(page.locator('[title="e2e-chats-project"]')).toBeVisible({ timeout: 5_000 });

    // Mock dialog to return a second path
    await electronApp.evaluate(({ ipcMain }) => {
      ipcMain.removeHandler('dialog:openDirectory');
      ipcMain.handle('dialog:openDirectory', () => '/tmp/e2e-chats-project-2');
    });

    // Add second project
    await page.click('[aria-label="Add project"]');
    await expect(page.locator('[title="e2e-chats-project-2"]')).toBeVisible({ timeout: 5_000 });

    // Click first project
    await page.click('[title="e2e-chats-project"]');
    // Click second project — should not crash and should show its own (empty) chat list
    await page.click('[title="e2e-chats-project-2"]');

    // Both projects are still in the rail
    await expect(page.locator('[title="e2e-chats-project"]')).toBeVisible();
    await expect(page.locator('[title="e2e-chats-project-2"]')).toBeVisible();
  });
});
```

> **Note:** The selector `[data-testid="chat-list"]` requires a `data-testid="chat-list"` attribute on the chat list container in the renderer. Alternatively use a text-based selector that matches the empty state message. Check the actual component and adjust the selector.

### Step 2: Run the E2E tests

```bash
pnpm test:e2e
```

Expected: all tests pass.

### Step 3: Commit

```bash
git add tests/e2e/chats.spec.ts
git commit -m "test: add Layer 2 Playwright E2E tests for project/chat navigation"
```

---

## Final Verification

Run all test layers:

```bash
# Layer 0: existing unit tests
pnpm test

# Layer 1: API integration tests
pnpm test:api

# Layer 2: Playwright E2E (local only)
pnpm test:e2e
```

Expected: all pass.

## File Structure Created

```
tests/
  api/
    helpers/
      daemon.ts           # spawn/teardown daemon fixture + free-port helper
    projects.test.ts      # projects CRUD integration tests
    chats.test.ts         # chats HTTP endpoint tests
    delete-cascade.test.ts
  e2e/
    fixtures.ts           # Playwright Electron app launch/teardown fixture
    projects.spec.ts      # ProjectRail add/remove flow
    chats.spec.ts         # Project selection and chat list rendering
  vitest.config.ts        # config for Layer 1 API tests
  playwright.config.ts    # config for Layer 2 E2E tests
```

Modified files:
- `packages/core/src/config.ts` — env var overrides (`MAINFRAME_PORT`, `MAINFRAME_DATA_DIR`)
- `packages/desktop/src/preload/index.ts` — expose `daemonPort` via context bridge
- `packages/desktop/src/renderer/lib/api/http.ts` — read port from `window.mainframe.daemonPort`
- `packages/desktop/src/renderer/lib/client.ts` — read port from `window.mainframe.daemonPort`
- `packages/desktop/src/renderer/components/ProjectRail.tsx` — add `aria-label` props for E2E selectors
- `.github/workflows/ci.yml` — add `pnpm test:api` step
- Root `package.json` — add `test:api` and `test:e2e` scripts
